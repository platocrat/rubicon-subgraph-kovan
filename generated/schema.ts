// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class UserTrade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("isLimit", Value.fromBoolean(false));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("taker", Value.fromBytes(Bytes.empty()));
    this.set("payGem", Value.fromBytes(Bytes.empty()));
    this.set("buyGem", Value.fromBytes(Bytes.empty()));
    this.set("payAmount", Value.fromBigInt(BigInt.zero()));
    this.set("buyAmount", Value.fromBigInt(BigInt.zero()));
    this.set("completed", Value.fromBoolean(false));
    this.set("killed", Value.fromBoolean(false));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserTrade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserTrade entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserTrade", id.toString(), this);
    }
  }

  static load(id: string): UserTrade | null {
    return changetype<UserTrade | null>(store.get("UserTrade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isLimit(): boolean {
    let value = this.get("isLimit");
    return value!.toBoolean();
  }

  set isLimit(value: boolean) {
    this.set("isLimit", Value.fromBoolean(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get taker(): Bytes {
    let value = this.get("taker");
    return value!.toBytes();
  }

  set taker(value: Bytes) {
    this.set("taker", Value.fromBytes(value));
  }

  get payGem(): Bytes {
    let value = this.get("payGem");
    return value!.toBytes();
  }

  set payGem(value: Bytes) {
    this.set("payGem", Value.fromBytes(value));
  }

  get buyGem(): Bytes {
    let value = this.get("buyGem");
    return value!.toBytes();
  }

  set buyGem(value: Bytes) {
    this.set("buyGem", Value.fromBytes(value));
  }

  get payAmount(): BigInt {
    let value = this.get("payAmount");
    return value!.toBigInt();
  }

  set payAmount(value: BigInt) {
    this.set("payAmount", Value.fromBigInt(value));
  }

  get buyAmount(): BigInt {
    let value = this.get("buyAmount");
    return value!.toBigInt();
  }

  set buyAmount(value: BigInt) {
    this.set("buyAmount", Value.fromBigInt(value));
  }

  get completed(): boolean {
    let value = this.get("completed");
    return value!.toBoolean();
  }

  set completed(value: boolean) {
    this.set("completed", Value.fromBoolean(value));
  }

  get killed(): boolean {
    let value = this.get("killed");
    return value!.toBoolean();
  }

  set killed(value: boolean) {
    this.set("killed", Value.fromBoolean(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FeeTake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pair", Value.fromBytes(Bytes.empty()));
    this.set("asset", Value.fromBytes(Bytes.empty()));
    this.set("taker", Value.fromBytes(Bytes.empty()));
    this.set("feeTo", Value.fromBytes(Bytes.empty()));
    this.set("feeAmt", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeeTake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FeeTake entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FeeTake", id.toString(), this);
    }
  }

  static load(id: string): FeeTake | null {
    return changetype<FeeTake | null>(store.get("FeeTake", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pair(): Bytes {
    let value = this.get("pair");
    return value!.toBytes();
  }

  set pair(value: Bytes) {
    this.set("pair", Value.fromBytes(value));
  }

  get asset(): Bytes {
    let value = this.get("asset");
    return value!.toBytes();
  }

  set asset(value: Bytes) {
    this.set("asset", Value.fromBytes(value));
  }

  get taker(): Bytes {
    let value = this.get("taker");
    return value!.toBytes();
  }

  set taker(value: Bytes) {
    this.set("taker", Value.fromBytes(value));
  }

  get feeTo(): Bytes {
    let value = this.get("feeTo");
    return value!.toBytes();
  }

  set feeTo(value: Bytes) {
    this.set("feeTo", Value.fromBytes(value));
  }

  get feeAmt(): BigInt {
    let value = this.get("feeAmt");
    return value!.toBigInt();
  }

  set feeAmt(value: BigInt) {
    this.set("feeAmt", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class LogBump extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pair", Value.fromBytes(Bytes.empty()));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("buy_gem", Value.fromBytes(Bytes.empty()));
    this.set("pay_amt", Value.fromBigInt(BigInt.zero()));
    this.set("buy_amt", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogBump entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogBump entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogBump", id.toString(), this);
    }
  }

  static load(id: string): LogBump | null {
    return changetype<LogBump | null>(store.get("LogBump", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pair(): Bytes {
    let value = this.get("pair");
    return value!.toBytes();
  }

  set pair(value: Bytes) {
    this.set("pair", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get buy_gem(): Bytes {
    let value = this.get("buy_gem");
    return value!.toBytes();
  }

  set buy_gem(value: Bytes) {
    this.set("buy_gem", Value.fromBytes(value));
  }

  get pay_amt(): BigInt {
    let value = this.get("pay_amt");
    return value!.toBigInt();
  }

  set pay_amt(value: BigInt) {
    this.set("pay_amt", Value.fromBigInt(value));
  }

  get buy_amt(): BigInt {
    let value = this.get("buy_amt");
    return value!.toBigInt();
  }

  set buy_amt(value: BigInt) {
    this.set("buy_amt", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class LogBuyEnabled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("isEnabled", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogBuyEnabled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogBuyEnabled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogBuyEnabled", id.toString(), this);
    }
  }

  static load(id: string): LogBuyEnabled | null {
    return changetype<LogBuyEnabled | null>(store.get("LogBuyEnabled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isEnabled(): boolean {
    let value = this.get("isEnabled");
    return value!.toBoolean();
  }

  set isEnabled(value: boolean) {
    this.set("isEnabled", Value.fromBoolean(value));
  }
}

export class LogDelete extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("keeper", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogDelete entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogDelete entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogDelete", id.toString(), this);
    }
  }

  static load(id: string): LogDelete | null {
    return changetype<LogDelete | null>(store.get("LogDelete", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get keeper(): Bytes {
    let value = this.get("keeper");
    return value!.toBytes();
  }

  set keeper(value: Bytes) {
    this.set("keeper", Value.fromBytes(value));
  }
}

export class LogInsert extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("keeper", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogInsert entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogInsert entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogInsert", id.toString(), this);
    }
  }

  static load(id: string): LogInsert | null {
    return changetype<LogInsert | null>(store.get("LogInsert", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get keeper(): Bytes {
    let value = this.get("keeper");
    return value!.toBytes();
  }

  set keeper(value: Bytes) {
    this.set("keeper", Value.fromBytes(value));
  }
}

export class LogInt extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("lol", Value.fromString(""));
    this.set("input", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogInt entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogInt entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogInt", id.toString(), this);
    }
  }

  static load(id: string): LogInt | null {
    return changetype<LogInt | null>(store.get("LogInt", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lol(): string {
    let value = this.get("lol");
    return value!.toString();
  }

  set lol(value: string) {
    this.set("lol", Value.fromString(value));
  }

  get input(): BigInt {
    let value = this.get("input");
    return value!.toBigInt();
  }

  set input(value: BigInt) {
    this.set("input", Value.fromBigInt(value));
  }
}

export class LogItemUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogItemUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogItemUpdate entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogItemUpdate", id.toString(), this);
    }
  }

  static load(id: string): LogItemUpdate | null {
    return changetype<LogItemUpdate | null>(store.get("LogItemUpdate", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class LogKill extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pair", Value.fromBytes(Bytes.empty()));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("buy_gem", Value.fromBytes(Bytes.empty()));
    this.set("pay_amt", Value.fromBigInt(BigInt.zero()));
    this.set("buy_amt", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogKill entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogKill entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogKill", id.toString(), this);
    }
  }

  static load(id: string): LogKill | null {
    return changetype<LogKill | null>(store.get("LogKill", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pair(): Bytes {
    let value = this.get("pair");
    return value!.toBytes();
  }

  set pair(value: Bytes) {
    this.set("pair", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get buy_gem(): Bytes {
    let value = this.get("buy_gem");
    return value!.toBytes();
  }

  set buy_gem(value: Bytes) {
    this.set("buy_gem", Value.fromBytes(value));
  }

  get pay_amt(): BigInt {
    let value = this.get("pay_amt");
    return value!.toBigInt();
  }

  set pay_amt(value: BigInt) {
    this.set("pay_amt", Value.fromBigInt(value));
  }

  get buy_amt(): BigInt {
    let value = this.get("buy_amt");
    return value!.toBigInt();
  }

  set buy_amt(value: BigInt) {
    this.set("buy_amt", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LogMake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pair", Value.fromBytes(Bytes.empty()));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("buy_gem", Value.fromBytes(Bytes.empty()));
    this.set("pay_amt", Value.fromBigInt(BigInt.zero()));
    this.set("buy_amt", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogMake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogMake entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogMake", id.toString(), this);
    }
  }

  static load(id: string): LogMake | null {
    return changetype<LogMake | null>(store.get("LogMake", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pair(): Bytes {
    let value = this.get("pair");
    return value!.toBytes();
  }

  set pair(value: Bytes) {
    this.set("pair", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get buy_gem(): Bytes {
    let value = this.get("buy_gem");
    return value!.toBytes();
  }

  set buy_gem(value: Bytes) {
    this.set("buy_gem", Value.fromBytes(value));
  }

  get pay_amt(): BigInt {
    let value = this.get("pay_amt");
    return value!.toBigInt();
  }

  set pay_amt(value: BigInt) {
    this.set("pay_amt", Value.fromBigInt(value));
  }

  get buy_amt(): BigInt {
    let value = this.get("buy_amt");
    return value!.toBigInt();
  }

  set buy_amt(value: BigInt) {
    this.set("buy_amt", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LogMatch extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogMatch entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogMatch entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogMatch", id.toString(), this);
    }
  }

  static load(id: string): LogMatch | null {
    return changetype<LogMatch | null>(store.get("LogMatch", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class LogMatchingEnabled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("isEnabled", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogMatchingEnabled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogMatchingEnabled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogMatchingEnabled", id.toString(), this);
    }
  }

  static load(id: string): LogMatchingEnabled | null {
    return changetype<LogMatchingEnabled | null>(
      store.get("LogMatchingEnabled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isEnabled(): boolean {
    let value = this.get("isEnabled");
    return value!.toBoolean();
  }

  set isEnabled(value: boolean) {
    this.set("isEnabled", Value.fromBoolean(value));
  }
}

export class LogMinSell extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("min_amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogMinSell entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogMinSell entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogMinSell", id.toString(), this);
    }
  }

  static load(id: string): LogMinSell | null {
    return changetype<LogMinSell | null>(store.get("LogMinSell", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get min_amount(): BigInt {
    let value = this.get("min_amount");
    return value!.toBigInt();
  }

  set min_amount(value: BigInt) {
    this.set("min_amount", Value.fromBigInt(value));
  }
}

export class LogNote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sig", Value.fromBytes(Bytes.empty()));
    this.set("guy", Value.fromBytes(Bytes.empty()));
    this.set("foo", Value.fromBytes(Bytes.empty()));
    this.set("bar", Value.fromBytes(Bytes.empty()));
    this.set("wad", Value.fromBigInt(BigInt.zero()));
    this.set("fax", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogNote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogNote entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogNote", id.toString(), this);
    }
  }

  static load(id: string): LogNote | null {
    return changetype<LogNote | null>(store.get("LogNote", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sig(): Bytes {
    let value = this.get("sig");
    return value!.toBytes();
  }

  set sig(value: Bytes) {
    this.set("sig", Value.fromBytes(value));
  }

  get guy(): Bytes {
    let value = this.get("guy");
    return value!.toBytes();
  }

  set guy(value: Bytes) {
    this.set("guy", Value.fromBytes(value));
  }

  get foo(): Bytes {
    let value = this.get("foo");
    return value!.toBytes();
  }

  set foo(value: Bytes) {
    this.set("foo", Value.fromBytes(value));
  }

  get bar(): Bytes {
    let value = this.get("bar");
    return value!.toBytes();
  }

  set bar(value: Bytes) {
    this.set("bar", Value.fromBytes(value));
  }

  get wad(): BigInt {
    let value = this.get("wad");
    return value!.toBigInt();
  }

  set wad(value: BigInt) {
    this.set("wad", Value.fromBigInt(value));
  }

  get fax(): Bytes {
    let value = this.get("fax");
    return value!.toBytes();
  }

  set fax(value: Bytes) {
    this.set("fax", Value.fromBytes(value));
  }
}

export class LogSetAuthority extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("authority", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogSetAuthority entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogSetAuthority entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogSetAuthority", id.toString(), this);
    }
  }

  static load(id: string): LogSetAuthority | null {
    return changetype<LogSetAuthority | null>(store.get("LogSetAuthority", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get authority(): Bytes {
    let value = this.get("authority");
    return value!.toBytes();
  }

  set authority(value: Bytes) {
    this.set("authority", Value.fromBytes(value));
  }
}

export class LogSetOwner extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogSetOwner entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogSetOwner entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogSetOwner", id.toString(), this);
    }
  }

  static load(id: string): LogSetOwner | null {
    return changetype<LogSetOwner | null>(store.get("LogSetOwner", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes | null {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes | null) {
    if (!value) {
      this.unset("owner");
    } else {
      this.set("owner", Value.fromBytes(<Bytes>value));
    }
  }
}

export class LogSortedOffer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogSortedOffer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogSortedOffer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogSortedOffer", id.toString(), this);
    }
  }

  static load(id: string): LogSortedOffer | null {
    return changetype<LogSortedOffer | null>(store.get("LogSortedOffer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class LogTake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pair", Value.fromBytes(Bytes.empty()));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("taker", Value.fromBytes(Bytes.empty()));
    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("buy_gem", Value.fromBytes(Bytes.empty()));
    this.set("take_amt", Value.fromBigInt(BigInt.zero()));
    this.set("give_amt", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogTake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogTake entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogTake", id.toString(), this);
    }
  }

  static load(id: string): LogTake | null {
    return changetype<LogTake | null>(store.get("LogTake", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pair(): Bytes {
    let value = this.get("pair");
    return value!.toBytes();
  }

  set pair(value: Bytes) {
    this.set("pair", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get taker(): Bytes {
    let value = this.get("taker");
    return value!.toBytes();
  }

  set taker(value: Bytes) {
    this.set("taker", Value.fromBytes(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get buy_gem(): Bytes {
    let value = this.get("buy_gem");
    return value!.toBytes();
  }

  set buy_gem(value: Bytes) {
    this.set("buy_gem", Value.fromBytes(value));
  }

  get take_amt(): BigInt {
    let value = this.get("take_amt");
    return value!.toBigInt();
  }

  set take_amt(value: BigInt) {
    this.set("take_amt", Value.fromBigInt(value));
  }

  get give_amt(): BigInt {
    let value = this.get("give_amt");
    return value!.toBigInt();
  }

  set give_amt(value: BigInt) {
    this.set("give_amt", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LogTrade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("pay_amt", Value.fromBigInt(BigInt.zero()));
    this.set("pay_gem", Value.fromBytes(Bytes.empty()));
    this.set("buy_amt", Value.fromBigInt(BigInt.zero()));
    this.set("buy_gem", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogTrade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogTrade entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogTrade", id.toString(), this);
    }
  }

  static load(id: string): LogTrade | null {
    return changetype<LogTrade | null>(store.get("LogTrade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pay_amt(): BigInt {
    let value = this.get("pay_amt");
    return value!.toBigInt();
  }

  set pay_amt(value: BigInt) {
    this.set("pay_amt", Value.fromBigInt(value));
  }

  get pay_gem(): Bytes {
    let value = this.get("pay_gem");
    return value!.toBytes();
  }

  set pay_gem(value: Bytes) {
    this.set("pay_gem", Value.fromBytes(value));
  }

  get buy_amt(): BigInt {
    let value = this.get("buy_amt");
    return value!.toBigInt();
  }

  set buy_amt(value: BigInt) {
    this.set("buy_amt", Value.fromBigInt(value));
  }

  get buy_gem(): Bytes {
    let value = this.get("buy_gem");
    return value!.toBytes();
  }

  set buy_gem(value: Bytes) {
    this.set("buy_gem", Value.fromBytes(value));
  }
}

export class LogUnsortedOffer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogUnsortedOffer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LogUnsortedOffer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LogUnsortedOffer", id.toString(), this);
    }
  }

  static load(id: string): LogUnsortedOffer | null {
    return changetype<LogUnsortedOffer | null>(
      store.get("LogUnsortedOffer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class OfferDeleted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OfferDeleted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OfferDeleted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OfferDeleted", id.toString(), this);
    }
  }

  static load(id: string): OfferDeleted | null {
    return changetype<OfferDeleted | null>(store.get("OfferDeleted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class RubiconMarket extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RubiconMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RubiconMarket entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RubiconMarket", id.toString(), this);
    }
  }

  static load(id: string): RubiconMarket | null {
    return changetype<RubiconMarket | null>(store.get("RubiconMarket", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes | null {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes | null) {
    if (!value) {
      this.unset("owner");
    } else {
      this.set("owner", Value.fromBytes(<Bytes>value));
    }
  }
}
